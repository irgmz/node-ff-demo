{"version":3,"file":"esm.min.js","sources":["../../src/feature-repository.ts","../../src/util.ts","../../src/mongrule.ts","../../src/GrowthBook.ts"],"sourcesContent":["import {\n  ApiHost,\n  CacheSettings,\n  ClientKey,\n  FeatureApiResponse,\n  Polyfills,\n  RepositoryKey,\n} from \"./types/growthbook\";\nimport type { GrowthBook } from \".\";\n\ntype CacheEntry = {\n  data: FeatureApiResponse;\n  version: string;\n  staleAt: Date;\n};\ntype ScopedChannel = {\n  src: EventSource;\n  cb: (event: MessageEvent<string>) => void;\n  errors: number;\n};\n\n// Config settings\nconst cacheSettings: CacheSettings = {\n  // Consider a fetch stale after 1 minute\n  staleTTL: 1000 * 60,\n  cacheKey: \"gbFeaturesCache\",\n  backgroundSync: true,\n};\nconst polyfills: Polyfills = {\n  fetch: globalThis.fetch ? globalThis.fetch.bind(globalThis) : undefined,\n  SubtleCrypto: globalThis.crypto ? globalThis.crypto.subtle : undefined,\n  EventSource: globalThis.EventSource,\n};\ntry {\n  if (globalThis.localStorage) {\n    polyfills.localStorage = globalThis.localStorage;\n  }\n} catch (e) {\n  // Ignore localStorage errors\n}\n\n// Global state\nconst subscribedInstances: Map<RepositoryKey, Set<GrowthBook>> = new Map();\nlet cacheInitialized = false;\nconst cache: Map<RepositoryKey, CacheEntry> = new Map();\nconst activeFetches: Map<\n  RepositoryKey,\n  Promise<FeatureApiResponse>\n> = new Map();\nconst streams: Map<RepositoryKey, ScopedChannel> = new Map();\nconst supportsSSE: Set<RepositoryKey> = new Set();\n\n// Public functions\nexport function setPolyfills(overrides: Partial<Polyfills>): void {\n  Object.assign(polyfills, overrides);\n}\nexport function configureCache(overrides: Partial<CacheSettings>): void {\n  Object.assign(cacheSettings, overrides);\n  if (!cacheSettings.backgroundSync) {\n    clearAutoRefresh();\n  }\n}\n\nexport async function clearCache(): Promise<void> {\n  cache.clear();\n  activeFetches.clear();\n  clearAutoRefresh();\n  cacheInitialized = false;\n  await updatePersistentCache();\n}\n\nexport async function refreshFeatures(\n  instance: GrowthBook,\n  timeout?: number,\n  skipCache?: boolean,\n  allowStale?: boolean,\n  updateInstance?: boolean\n): Promise<void> {\n  const data = await fetchFeaturesWithCache(\n    instance,\n    allowStale,\n    timeout,\n    skipCache\n  );\n  updateInstance && data && (await setFeaturesOnInstance(instance, data));\n}\n\n// Subscribe a GrowthBook instance to feature changes\nexport function subscribe(instance: GrowthBook): void {\n  const [key] = getKey(instance);\n  const subs = subscribedInstances.get(key) || new Set();\n  subs.add(instance);\n  subscribedInstances.set(key, subs);\n}\nexport function unsubscribe(instance: GrowthBook): void {\n  subscribedInstances.forEach((s) => s.delete(instance));\n}\n\n// Private functions\nasync function updatePersistentCache() {\n  try {\n    if (!polyfills.localStorage) return;\n    await polyfills.localStorage.setItem(\n      cacheSettings.cacheKey,\n      JSON.stringify(Array.from(cache.entries()))\n    );\n  } catch (e) {\n    // Ignore localStorage errors\n  }\n}\n\nasync function fetchFeaturesWithCache(\n  instance: GrowthBook,\n  allowStale?: boolean,\n  timeout?: number,\n  skipCache?: boolean\n): Promise<FeatureApiResponse | null> {\n  const [key] = getKey(instance);\n  const now = new Date();\n  await initializeCache();\n  const existing = cache.get(key);\n  if (existing && !skipCache && (allowStale || existing.staleAt > now)) {\n    // Reload features in the backgroud if stale\n    if (existing.staleAt < now) {\n      fetchFeatures(instance);\n    }\n    // Otherwise, if we don't need to refresh now, start a background sync\n    else {\n      startAutoRefresh(instance);\n    }\n    return existing.data;\n  } else {\n    const data = await promiseTimeout(fetchFeatures(instance), timeout);\n    return data;\n  }\n}\n\nfunction getKey(instance: GrowthBook): [RepositoryKey, ApiHost, ClientKey] {\n  const [apiHost, clientKey] = instance.getApiInfo();\n  return [`${apiHost}||${clientKey}`, apiHost, clientKey];\n}\n\n// Guarantee the promise always resolves within {timeout} ms\n// Resolved value will be `null` when there's an error or it takes too long\n// Note: The promise will continue running in the background, even if the timeout is hit\nfunction promiseTimeout<T>(\n  promise: Promise<T>,\n  timeout?: number\n): Promise<T | null> {\n  return new Promise((resolve) => {\n    let resolved = false;\n    let timer: unknown;\n    const finish = (data?: T) => {\n      if (resolved) return;\n      resolved = true;\n      timer && clearTimeout(timer as NodeJS.Timer);\n      resolve(data || null);\n    };\n\n    if (timeout) {\n      timer = setTimeout(() => finish(), timeout);\n    }\n\n    promise.then((data) => finish(data)).catch(() => finish());\n  });\n}\n\n// Populate cache from localStorage (if available)\nasync function initializeCache(): Promise<void> {\n  if (cacheInitialized) return;\n  cacheInitialized = true;\n  try {\n    if (polyfills.localStorage) {\n      const value = await polyfills.localStorage.getItem(\n        cacheSettings.cacheKey\n      );\n      if (value) {\n        const parsed: [RepositoryKey, CacheEntry][] = JSON.parse(value);\n        if (parsed && Array.isArray(parsed)) {\n          parsed.forEach(([key, data]) => {\n            cache.set(key, {\n              ...data,\n              staleAt: new Date(data.staleAt),\n            });\n          });\n        }\n      }\n    }\n  } catch (e) {\n    // Ignore localStorage errors\n  }\n}\n\n// Called whenever new features are fetched from the API\nfunction onNewFeatureData(key: RepositoryKey, data: FeatureApiResponse): void {\n  // If contents haven't changed, ignore the update, extend the stale TTL\n  const version = data.dateUpdated || \"\";\n  const staleAt = new Date(Date.now() + cacheSettings.staleTTL);\n  const existing = cache.get(key);\n  if (existing && version && existing.version === version) {\n    existing.staleAt = staleAt;\n    return;\n  }\n\n  // Update in-memory cache\n  cache.set(key, {\n    data,\n    version,\n    staleAt,\n  });\n  // Update local storage (don't await this, just update asynchronously)\n  updatePersistentCache();\n\n  // Update features for all subscribed GrowthBook instances\n  const instances = subscribedInstances.get(key);\n  instances &&\n    instances.forEach((instance) => setFeaturesOnInstance(instance, data));\n}\n\nasync function setFeaturesOnInstance(\n  instance: GrowthBook,\n  data: FeatureApiResponse\n): Promise<void> {\n  await (data.encryptedFeatures\n    ? instance.setEncryptedFeatures(\n        data.encryptedFeatures,\n        undefined,\n        polyfills.SubtleCrypto\n      )\n    : instance.setFeatures(data.features || instance.getFeatures()));\n}\n\nasync function fetchFeatures(\n  instance: GrowthBook\n): Promise<FeatureApiResponse> {\n  const [key, apiHost, clientKey] = getKey(instance);\n  const endpoint = apiHost + \"/api/features/\" + clientKey;\n\n  let promise = activeFetches.get(key);\n  if (!promise) {\n    promise = (polyfills.fetch as typeof globalThis.fetch)(endpoint)\n      // TODO: auto-retry if status code indicates a temporary error\n      .then((res) => {\n        if (res.headers.get(\"x-sse-support\") === \"enabled\") {\n          supportsSSE.add(key);\n        }\n        return res.json();\n      })\n      .then((data: FeatureApiResponse) => {\n        onNewFeatureData(key, data);\n        startAutoRefresh(instance);\n        activeFetches.delete(key);\n        return data;\n      })\n      .catch((e) => {\n        process.env.NODE_ENV !== \"production\" &&\n          instance.log(\"Error fetching features\", {\n            apiHost,\n            clientKey,\n            error: e ? e.message : null,\n          });\n        activeFetches.delete(key);\n        return Promise.resolve({});\n      });\n    activeFetches.set(key, promise);\n  }\n  return await promise;\n}\n\n// Watch a feature endpoint for changes\n// Will prefer SSE if enabled, otherwise fall back to cron\nfunction startAutoRefresh(instance: GrowthBook) {\n  const [key, apiHost, clientKey] = getKey(instance);\n  if (\n    cacheSettings.backgroundSync &&\n    supportsSSE.has(key) &&\n    polyfills.EventSource\n  ) {\n    if (streams.has(key)) return;\n    const channel: ScopedChannel = {\n      src: new polyfills.EventSource(`${apiHost}/sub/${clientKey}`),\n      cb: (event: MessageEvent<string>) => {\n        try {\n          const json: FeatureApiResponse = JSON.parse(event.data);\n          onNewFeatureData(key, json);\n          // Reset error count on success\n          channel.errors = 0;\n        } catch (e) {\n          process.env.NODE_ENV !== \"production\" &&\n            instance.log(\"SSE Error\", {\n              apiHost,\n              clientKey,\n              error: e ? (e as Error).message : null,\n            });\n          onSSEError(channel, key);\n        }\n      },\n      errors: 0,\n    };\n    streams.set(key, channel);\n    channel.src.addEventListener(\"features\", channel.cb);\n\n    channel.src.onerror = () => {\n      onSSEError(channel, key);\n    };\n  }\n}\n\nfunction onSSEError(channel: ScopedChannel, key: RepositoryKey) {\n  channel.errors++;\n  if (channel.errors > 3 || channel.src.readyState === 2) {\n    destroyChannel(channel, key);\n  }\n}\n\nfunction destroyChannel(channel: ScopedChannel, key: RepositoryKey) {\n  channel.src.onerror = null;\n  channel.src.close();\n  streams.delete(key);\n}\n\nfunction clearAutoRefresh() {\n  // Clear list of which keys are auto-updated\n  supportsSSE.clear();\n\n  // Stop listening for any SSE events\n  streams.forEach(destroyChannel);\n\n  // Remove all references to GrowthBook instances\n  subscribedInstances.clear();\n}\n","import { VariationRange } from \"./types/growthbook\";\n\nfunction hashFnv32a(str: string): number {\n  let hval = 0x811c9dc5;\n  const l = str.length;\n\n  for (let i = 0; i < l; i++) {\n    hval ^= str.charCodeAt(i);\n    hval +=\n      (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);\n  }\n  return hval >>> 0;\n}\n\nexport function hash(seed: string, value: string, version: number): number {\n  // New unbiased hashing algorithm\n  if (version === 2) {\n    return (hashFnv32a(hashFnv32a(seed + value) + \"\") % 10000) / 10000;\n  }\n  // Original biased hashing algorithm (keep for backwards compatibility)\n  if (version === 1) {\n    return (hashFnv32a(value + seed) % 1000) / 1000;\n  }\n\n  // Unknown hash version\n  return -1;\n}\n\nexport function getEqualWeights(n: number): number[] {\n  if (n <= 0) return [];\n  return new Array(n).fill(1 / n);\n}\n\nexport function inRange(n: number, range: VariationRange): boolean {\n  return n >= range[0] && n < range[1];\n}\n\nexport function inNamespace(\n  hashValue: string,\n  namespace: [string, number, number]\n): boolean {\n  const n = hash(\"__\" + namespace[0], hashValue, 1);\n  return n >= namespace[1] && n < namespace[2];\n}\n\nexport function chooseVariation(n: number, ranges: VariationRange[]): number {\n  for (let i = 0; i < ranges.length; i++) {\n    if (inRange(n, ranges[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nexport function getUrlRegExp(regexString: string): RegExp | undefined {\n  try {\n    const escaped = regexString.replace(/([^\\\\])\\//g, \"$1\\\\/\");\n    return new RegExp(escaped);\n  } catch (e) {\n    console.error(e);\n    return undefined;\n  }\n}\n\nexport function getBucketRanges(\n  numVariations: number,\n  coverage: number | undefined,\n  weights?: number[]\n): VariationRange[] {\n  coverage = coverage === undefined ? 1 : coverage;\n\n  // Make sure coverage is within bounds\n  if (coverage < 0) {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.error(\"Experiment.coverage must be greater than or equal to 0\");\n    }\n    coverage = 0;\n  } else if (coverage > 1) {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.error(\"Experiment.coverage must be less than or equal to 1\");\n    }\n    coverage = 1;\n  }\n\n  // Default to equal weights if missing or invalid\n  const equal = getEqualWeights(numVariations);\n  weights = weights || equal;\n  if (weights.length !== numVariations) {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.error(\n        \"Experiment.weights array must be the same length as Experiment.variations\"\n      );\n    }\n    weights = equal;\n  }\n\n  // If weights don't add up to 1 (or close to it), default to equal weights\n  const totalWeight = weights.reduce((w, sum) => sum + w, 0);\n  if (totalWeight < 0.99 || totalWeight > 1.01) {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.error(\"Experiment.weights must add up to 1\");\n    }\n    weights = equal;\n  }\n\n  // Covert weights to ranges\n  let cumulative = 0;\n  return weights.map((w) => {\n    const start = cumulative;\n    cumulative += w;\n    return [start, start + (coverage as number) * w];\n  }) as VariationRange[];\n}\n\nexport function getQueryStringOverride(\n  id: string,\n  url: string,\n  numVariations: number\n) {\n  if (!url) {\n    return null;\n  }\n\n  const search = url.split(\"?\")[1];\n  if (!search) {\n    return null;\n  }\n\n  const match = search\n    .replace(/#.*/, \"\") // Get rid of anchor\n    .split(\"&\") // Split into key/value pairs\n    .map((kv) => kv.split(\"=\", 2))\n    .filter(([k]) => k === id) // Look for key that matches the experiment id\n    .map(([, v]) => parseInt(v)); // Parse the value into an integer\n\n  if (match.length > 0 && match[0] >= 0 && match[0] < numVariations)\n    return match[0];\n\n  return null;\n}\n\nexport function isIncluded(include: () => boolean) {\n  try {\n    return include();\n  } catch (e) {\n    console.error(e);\n    return false;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {\n  ConditionInterface,\n  TestedObj,\n  ConditionValue,\n  Operator,\n  OperatorConditionValue,\n  VarType,\n} from \"./types/mongrule\";\n\nconst _regexCache: { [key: string]: RegExp } = {};\n\n// The top-level condition evaluation function\nexport function evalCondition(\n  obj: TestedObj,\n  condition: ConditionInterface\n): boolean {\n  // Recursive condition\n  if (\"$or\" in condition) {\n    return evalOr(obj, condition[\"$or\"] as ConditionInterface[]);\n  }\n  if (\"$nor\" in condition) {\n    return !evalOr(obj, condition[\"$nor\"] as ConditionInterface[]);\n  }\n  if (\"$and\" in condition) {\n    return evalAnd(obj, condition[\"$and\"] as ConditionInterface[]);\n  }\n  if (\"$not\" in condition) {\n    return !evalCondition(obj, condition[\"$not\"] as ConditionInterface);\n  }\n\n  // Condition is an object, keys are object paths, values are the condition for that path\n  for (const [k, v] of Object.entries(condition)) {\n    if (!evalConditionValue(v, getPath(obj, k))) return false;\n  }\n  return true;\n}\n\n// Return value at dot-separated path of an object\nfunction getPath(obj: TestedObj, path: string) {\n  const parts = path.split(\".\");\n  let current: any = obj;\n  for (let i = 0; i < parts.length; i++) {\n    if (current && typeof current === \"object\" && parts[i] in current) {\n      current = current[parts[i]];\n    } else {\n      return null;\n    }\n  }\n  return current;\n}\n\n// Transform a regex string into a real RegExp object\nfunction getRegex(regex: string): RegExp {\n  if (!_regexCache[regex]) {\n    _regexCache[regex] = new RegExp(regex.replace(/([^\\\\])\\//g, \"$1\\\\/\"));\n  }\n  return _regexCache[regex];\n}\n\n// Evaluate a single value against a condition\nfunction evalConditionValue(condition: ConditionValue, value: any) {\n  // Simple equality comparisons\n  if (typeof condition === \"string\") {\n    return value + \"\" === condition;\n  }\n  if (typeof condition === \"number\") {\n    return value * 1 === condition;\n  }\n  if (typeof condition === \"boolean\") {\n    return !!value === condition;\n  }\n  if (Array.isArray(condition) || !isOperatorObject(condition)) {\n    return JSON.stringify(value) === JSON.stringify(condition);\n  }\n\n  // This is a special operator condition and we should evaluate each one separately\n  for (const op in condition) {\n    if (\n      !evalOperatorCondition(\n        op as Operator,\n        value,\n        condition[op as keyof OperatorConditionValue]\n      )\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// If the object has only keys that start with '$'\nfunction isOperatorObject(obj: any): boolean {\n  const keys = Object.keys(obj);\n  return (\n    keys.length > 0 && keys.filter((k) => k[0] === \"$\").length === keys.length\n  );\n}\n\n// Return the data type of a value\nfunction getType(v: any): VarType | \"unknown\" {\n  if (v === null) return \"null\";\n  if (Array.isArray(v)) return \"array\";\n  const t = typeof v;\n  if ([\"string\", \"number\", \"boolean\", \"object\", \"undefined\"].includes(t)) {\n    return t as VarType;\n  }\n  return \"unknown\";\n}\n\n// At least one element of actual must match the expected condition/value\nfunction elemMatch(actual: any, expected: any) {\n  if (!Array.isArray(actual)) return false;\n  const check = isOperatorObject(expected)\n    ? (v: any) => evalConditionValue(expected, v)\n    : (v: any) => evalCondition(v, expected);\n  for (let i = 0; i < actual.length; i++) {\n    if (actual[i] && check(actual[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Evaluate a single operator condition\nfunction evalOperatorCondition(\n  operator: Operator,\n  actual: any,\n  expected: any\n): boolean {\n  switch (operator) {\n    case \"$eq\":\n      return actual === expected;\n    case \"$ne\":\n      return actual !== expected;\n    case \"$lt\":\n      return actual < expected;\n    case \"$lte\":\n      return actual <= expected;\n    case \"$gt\":\n      return actual > expected;\n    case \"$gte\":\n      return actual >= expected;\n    case \"$exists\":\n      return expected ? actual !== null : actual === null;\n    case \"$in\":\n      return expected.includes(actual);\n    case \"$nin\":\n      return !expected.includes(actual);\n    case \"$not\":\n      return !evalConditionValue(expected, actual);\n    case \"$size\":\n      if (!Array.isArray(actual)) return false;\n      return evalConditionValue(expected, actual.length);\n    case \"$elemMatch\":\n      return elemMatch(actual, expected);\n    case \"$all\":\n      if (!Array.isArray(actual)) return false;\n      for (let i = 0; i < expected.length; i++) {\n        let passed = false;\n        for (let j = 0; j < actual.length; j++) {\n          if (evalConditionValue(expected[i], actual[j])) {\n            passed = true;\n            break;\n          }\n        }\n        if (!passed) return false;\n      }\n      return true;\n    case \"$regex\":\n      try {\n        return getRegex(expected).test(actual);\n      } catch (e) {\n        return false;\n      }\n    case \"$type\":\n      return getType(actual) === expected;\n    default:\n      console.error(\"Unknown operator: \" + operator);\n      return false;\n  }\n}\n\n// Recursive $or rule\nfunction evalOr(obj: TestedObj, conditions: ConditionInterface[]): boolean {\n  if (!conditions.length) return true;\n  for (let i = 0; i < conditions.length; i++) {\n    if (evalCondition(obj, conditions[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Recursive $and rule\nfunction evalAnd(obj: TestedObj, conditions: ConditionInterface[]): boolean {\n  for (let i = 0; i < conditions.length; i++) {\n    if (!evalCondition(obj, conditions[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n","import type {\n  Context,\n  Experiment,\n  FeatureResult,\n  Result,\n  SubscriptionFunction,\n  FeatureDefinition,\n  FeatureResultSource,\n  Attributes,\n  WidenPrimitives,\n  RealtimeUsageData,\n  LoadFeaturesOptions,\n  RefreshFeaturesOptions,\n  ApiHost,\n  ClientKey,\n  VariationMeta,\n  Filter,\n  VariationRange,\n} from \"./types/growthbook\";\nimport type { ConditionInterface } from \"./types/mongrule\";\nimport {\n  getUrlRegExp,\n  isIncluded,\n  getBucketRanges,\n  hash,\n  chooseVariation,\n  getQueryStringOverride,\n  inNamespace,\n  inRange,\n} from \"./util\";\nimport { evalCondition } from \"./mongrule\";\nimport { refreshFeatures, subscribe, unsubscribe } from \"./feature-repository\";\n\nconst isBrowser =\n  typeof window !== \"undefined\" && typeof document !== \"undefined\";\n\nconst base64ToBuf = (b: string) =>\n  Uint8Array.from(atob(b), (c) => c.charCodeAt(0));\n\nexport class GrowthBook<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  AppFeatures extends Record<string, any> = Record<string, any>\n> {\n  // context is technically private, but some tools depend on it so we can't mangle the name\n  // _ctx below is a clone of this property that we use internally\n  private context: Context;\n  public debug: boolean;\n  public ready: boolean;\n\n  // Properties and methods that start with \"_\" are mangled by Terser (saves ~150 bytes)\n  private _ctx: Context;\n  private _renderer: null | (() => void);\n  private _trackedExperiments: Set<unknown>;\n  private _trackedFeatures: Record<string, string>;\n  private _subscriptions: Set<SubscriptionFunction>;\n  private _rtQueue: RealtimeUsageData[];\n  private _rtTimer: number;\n  private _assigned: Map<\n    string,\n    {\n      // eslint-disable-next-line\n      experiment: Experiment<any>;\n      // eslint-disable-next-line\n      result: Result<any>;\n    }\n  >;\n  // eslint-disable-next-line\n  private _forcedFeatureValues: Map<string, any>;\n  private _attributeOverrides: Attributes;\n\n  constructor(context?: Context) {\n    context = context || {};\n    // These properties are all initialized in the constructor instead of above\n    // This saves ~80 bytes in the final output\n    this._ctx = this.context = context;\n    this._renderer = null;\n    this._trackedExperiments = new Set();\n    this._trackedFeatures = {};\n    this.debug = false;\n    this._subscriptions = new Set();\n    this._rtQueue = [];\n    this._rtTimer = 0;\n    this.ready = false;\n    this._assigned = new Map();\n    this._forcedFeatureValues = new Map();\n    this._attributeOverrides = {};\n\n    if (context.features) {\n      this.ready = true;\n    }\n\n    if (isBrowser && context.enableDevMode) {\n      window._growthbook = this;\n      document.dispatchEvent(new Event(\"gbloaded\"));\n    }\n\n    if (context.clientKey) {\n      this._refresh({}, true, false);\n    }\n  }\n\n  public async loadFeatures(options?: LoadFeaturesOptions): Promise<void> {\n    await this._refresh(options, true, true);\n    if (options && options.autoRefresh) {\n      subscribe(this);\n    }\n  }\n\n  public async refreshFeatures(\n    options?: RefreshFeaturesOptions\n  ): Promise<void> {\n    await this._refresh(options, false, true);\n  }\n\n  public getApiInfo(): [ApiHost, ClientKey] {\n    return [\n      (this._ctx.apiHost || \"https://cdn.growthbook.io\").replace(/\\/*$/, \"\"),\n      this._ctx.clientKey || \"\",\n    ];\n  }\n\n  private async _refresh(\n    options?: RefreshFeaturesOptions,\n    allowStale?: boolean,\n    updateInstance?: boolean\n  ) {\n    options = options || {};\n    if (!this._ctx.clientKey) {\n      throw new Error(\"Missing clientKey\");\n    }\n    await refreshFeatures(\n      this,\n      options.timeout,\n      options.skipCache || this._ctx.enableDevMode,\n      allowStale,\n      updateInstance\n    );\n  }\n\n  private _render() {\n    if (this._renderer) {\n      this._renderer();\n    }\n  }\n\n  public setFeatures(features: Record<string, FeatureDefinition>) {\n    this._ctx.features = features;\n    this.ready = true;\n    this._render();\n  }\n\n  public async setEncryptedFeatures(\n    encryptedString: string,\n    decryptionKey?: string,\n    subtle?: SubtleCrypto\n  ): Promise<void> {\n    decryptionKey = decryptionKey || this._ctx.decryptionKey || \"\";\n    subtle = subtle || (globalThis.crypto && globalThis.crypto.subtle);\n    if (!subtle) {\n      throw new Error(\"No SubtleCrypto implementation found\");\n    }\n    try {\n      const key = await subtle.importKey(\n        \"raw\",\n        base64ToBuf(decryptionKey),\n        { name: \"AES-CBC\", length: 128 },\n        true,\n        [\"encrypt\", \"decrypt\"]\n      );\n      const [iv, cipherText] = encryptedString.split(\".\");\n      const plainTextBuffer = await subtle.decrypt(\n        { name: \"AES-CBC\", iv: base64ToBuf(iv) },\n        key,\n        base64ToBuf(cipherText)\n      );\n\n      this.setFeatures(JSON.parse(new TextDecoder().decode(plainTextBuffer)));\n    } catch (e) {\n      throw new Error(\"Failed to decrypt features\");\n    }\n  }\n\n  public setAttributes(attributes: Attributes) {\n    this._ctx.attributes = attributes;\n    this._render();\n  }\n\n  public setAttributeOverrides(overrides: Attributes) {\n    this._attributeOverrides = overrides;\n    this._render();\n  }\n  public setForcedVariations(vars: Record<string, number>) {\n    this._ctx.forcedVariations = vars || {};\n    this._render();\n  }\n  // eslint-disable-next-line\n  public setForcedFeatures(map: Map<string, any>) {\n    this._forcedFeatureValues = map;\n    this._render();\n  }\n\n  public getAttributes() {\n    return { ...this._ctx.attributes, ...this._attributeOverrides };\n  }\n\n  public getFeatures() {\n    return this._ctx.features || {};\n  }\n\n  public subscribe(cb: SubscriptionFunction): () => void {\n    this._subscriptions.add(cb);\n\n    return () => {\n      this._subscriptions.delete(cb);\n    };\n  }\n\n  public getAllResults() {\n    return new Map(this._assigned);\n  }\n\n  public destroy() {\n    // Release references to save memory\n    this._subscriptions.clear();\n    this._assigned.clear();\n    this._trackedExperiments.clear();\n    this._trackedFeatures = {};\n    this._rtQueue = [];\n    if (this._rtTimer) {\n      clearTimeout(this._rtTimer);\n    }\n    unsubscribe(this);\n\n    if (isBrowser && window._growthbook === this) {\n      delete window._growthbook;\n    }\n  }\n\n  public setRenderer(renderer: () => void) {\n    this._renderer = renderer;\n  }\n\n  public forceVariation(key: string, variation: number) {\n    this._ctx.forcedVariations = this._ctx.forcedVariations || {};\n    this._ctx.forcedVariations[key] = variation;\n    this._render();\n  }\n\n  public run<T>(experiment: Experiment<T>): Result<T> {\n    const result = this._run(experiment, null);\n    this._fireSubscriptions(experiment, result);\n    return result;\n  }\n\n  private _fireSubscriptions<T>(experiment: Experiment<T>, result: Result<T>) {\n    const key = experiment.key;\n\n    // If assigned variation has changed, fire subscriptions\n    const prev = this._assigned.get(key);\n    // TODO: what if the experiment definition has changed?\n    if (\n      !prev ||\n      prev.result.inExperiment !== result.inExperiment ||\n      prev.result.variationId !== result.variationId\n    ) {\n      this._assigned.set(key, { experiment, result });\n      this._subscriptions.forEach((cb) => {\n        try {\n          cb(experiment, result);\n        } catch (e) {\n          console.error(e);\n        }\n      });\n    }\n  }\n\n  private _trackFeatureUsage(key: string, res: FeatureResult): void {\n    // Don't track feature usage that was forced via an override\n    if (res.source === \"override\") return;\n\n    // Only track a feature once, unless the assigned value changed\n    const stringifiedValue = JSON.stringify(res.value);\n    if (this._trackedFeatures[key] === stringifiedValue) return;\n    this._trackedFeatures[key] = stringifiedValue;\n\n    // Fire user-supplied callback\n    if (this._ctx.onFeatureUsage) {\n      try {\n        this._ctx.onFeatureUsage(key, res);\n      } catch (e) {\n        // Ignore feature usage callback errors\n      }\n    }\n\n    // In browser environments, queue up feature usage to be tracked in batches\n    if (!isBrowser || !window.fetch) return;\n    this._rtQueue.push({\n      key,\n      on: res.on,\n    });\n    if (!this._rtTimer) {\n      this._rtTimer = window.setTimeout(() => {\n        // Reset the queue\n        this._rtTimer = 0;\n        const q = [...this._rtQueue];\n        this._rtQueue = [];\n\n        // Skip logging if a real-time usage key is not configured\n        if (!this._ctx.realtimeKey) return;\n\n        window\n          .fetch(\n            `https://rt.growthbook.io/?key=${\n              this._ctx.realtimeKey\n            }&events=${encodeURIComponent(JSON.stringify(q))}`,\n\n            {\n              cache: \"no-cache\",\n              mode: \"no-cors\",\n            }\n          )\n          .catch(() => {\n            // TODO: retry in case of network errors?\n          });\n      }, this._ctx.realtimeInterval || 2000);\n    }\n  }\n\n  private _getFeatureResult<T>(\n    key: string,\n    value: T,\n    source: FeatureResultSource,\n    ruleId?: string,\n    experiment?: Experiment<T>,\n    result?: Result<T>\n  ): FeatureResult<T> {\n    const ret: FeatureResult = {\n      value,\n      on: !!value,\n      off: !value,\n      source,\n      ruleId: ruleId || \"\",\n    };\n    if (experiment) ret.experiment = experiment;\n    if (result) ret.experimentResult = result;\n\n    // Track the usage of this feature in real-time\n    this._trackFeatureUsage(key, ret);\n\n    return ret;\n  }\n\n  public isOn<K extends string & keyof AppFeatures = string>(key: K): boolean {\n    return this.evalFeature(key).on;\n  }\n\n  public isOff<K extends string & keyof AppFeatures = string>(key: K): boolean {\n    return this.evalFeature(key).off;\n  }\n\n  public getFeatureValue<\n    V extends AppFeatures[K],\n    K extends string & keyof AppFeatures = string\n  >(key: K, defaultValue: V): WidenPrimitives<V> {\n    const value = this.evalFeature<WidenPrimitives<V>, K>(key).value;\n    return value === null ? (defaultValue as WidenPrimitives<V>) : value;\n  }\n\n  /**\n   * @deprecated Use {@link evalFeature}\n   * @param id\n   */\n  // eslint-disable-next-line\n  public feature<\n    V extends AppFeatures[K],\n    K extends string & keyof AppFeatures = string\n  >(id: K): FeatureResult<V | null> {\n    return this.evalFeature(id);\n  }\n\n  public evalFeature<\n    V extends AppFeatures[K],\n    K extends string & keyof AppFeatures = string\n  >(id: K): FeatureResult<V | null> {\n    // Global override\n    if (this._forcedFeatureValues.has(id)) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Global override\", {\n          id,\n          value: this._forcedFeatureValues.get(id),\n        });\n      return this._getFeatureResult(\n        id,\n        this._forcedFeatureValues.get(id),\n        \"override\"\n      );\n    }\n\n    // Unknown feature id\n    if (!this._ctx.features || !this._ctx.features[id]) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Unknown feature\", { id });\n      return this._getFeatureResult(id, null, \"unknownFeature\");\n    }\n\n    // Get the feature\n    const feature: FeatureDefinition<V> = this._ctx.features[id];\n\n    // Loop through the rules\n    if (feature.rules) {\n      for (const rule of feature.rules) {\n        // If it's a conditional rule, skip if the condition doesn't pass\n        if (rule.condition && !this._conditionPasses(rule.condition)) {\n          process.env.NODE_ENV !== \"production\" &&\n            this.log(\"Skip rule because of condition\", {\n              id,\n              rule,\n            });\n          continue;\n        }\n        // If there are filters for who is included (e.g. namespaces)\n        if (rule.filters && this._isFilteredOut(rule.filters)) {\n          process.env.NODE_ENV !== \"production\" &&\n            this.log(\"Skip rule because of filters\", {\n              id,\n              rule,\n            });\n          continue;\n        }\n\n        // Feature value is being forced\n        if (\"force\" in rule) {\n          // If this is a percentage rollout, skip if not included\n          if (\n            !this._isIncludedInRollout(\n              rule.seed || id,\n              rule.hashAttribute,\n              rule.range,\n              rule.coverage,\n              rule.hashVersion\n            )\n          ) {\n            process.env.NODE_ENV !== \"production\" &&\n              this.log(\"Skip rule because user not included in rollout\", {\n                id,\n                rule,\n              });\n            continue;\n          }\n\n          process.env.NODE_ENV !== \"production\" &&\n            this.log(\"Force value from rule\", {\n              id,\n              rule,\n            });\n\n          // If this was a remotely evaluated experiment, fire the tracking callbacks\n          if (rule.tracks) {\n            rule.tracks.forEach((t) => {\n              this._track(t.experiment, t.result);\n            });\n          }\n\n          return this._getFeatureResult(id, rule.force as V, \"force\", rule.id);\n        }\n        if (!rule.variations) {\n          process.env.NODE_ENV !== \"production\" &&\n            this.log(\"Skip invalid rule\", {\n              id,\n              rule,\n            });\n\n          continue;\n        }\n        // For experiment rules, run an experiment\n        const exp: Experiment<V> = {\n          variations: rule.variations as [V, V, ...V[]],\n          key: rule.key || id,\n        };\n        if (\"coverage\" in rule) exp.coverage = rule.coverage;\n        if (rule.weights) exp.weights = rule.weights;\n        if (rule.hashAttribute) exp.hashAttribute = rule.hashAttribute;\n        if (rule.namespace) exp.namespace = rule.namespace;\n        if (rule.meta) exp.meta = rule.meta;\n        if (rule.ranges) exp.ranges = rule.ranges;\n        if (rule.name) exp.name = rule.name;\n        if (rule.phase) exp.phase = rule.phase;\n        if (rule.seed) exp.seed = rule.seed;\n        if (rule.hashVersion) exp.hashVersion = rule.hashVersion;\n        if (rule.filters) exp.filters = rule.filters;\n\n        // Only return a value if the user is part of the experiment\n        const res = this._run(exp, id);\n        this._fireSubscriptions(exp, res);\n        if (res.inExperiment && !res.passthrough) {\n          return this._getFeatureResult(\n            id,\n            res.value,\n            \"experiment\",\n            rule.id,\n            exp,\n            res\n          );\n        }\n      }\n    }\n\n    process.env.NODE_ENV !== \"production\" &&\n      this.log(\"Use default value\", {\n        id,\n        value: feature.defaultValue,\n      });\n\n    // Fall back to using the default value\n    return this._getFeatureResult(\n      id,\n      feature.defaultValue === undefined ? null : feature.defaultValue,\n      \"defaultValue\"\n    );\n  }\n\n  private _isIncludedInRollout(\n    seed: string,\n    hashAttribute: string | undefined,\n    range: VariationRange | undefined,\n    coverage: number | undefined,\n    hashVersion: number | undefined\n  ): boolean {\n    if (!range && coverage === undefined) return true;\n\n    const { hashValue } = this._getHashAttribute(hashAttribute);\n    if (!hashValue) {\n      return false;\n    }\n\n    const n = hash(seed, hashValue, hashVersion || 1);\n\n    return range\n      ? inRange(n, range)\n      : coverage !== undefined\n      ? n <= coverage\n      : true;\n  }\n\n  private _conditionPasses(condition: ConditionInterface): boolean {\n    return evalCondition(this.getAttributes(), condition);\n  }\n\n  private _isFilteredOut(filters: Filter[]): boolean {\n    return filters.some((filter) => {\n      const { hashValue } = this._getHashAttribute(filter.attribute);\n      if (!hashValue) return true;\n      const n = hash(filter.seed, hashValue, filter.hashVersion || 2);\n      return !filter.ranges.some((r) => inRange(n, r));\n    });\n  }\n\n  private _run<T>(\n    experiment: Experiment<T>,\n    featureId: string | null\n  ): Result<T> {\n    const key = experiment.key;\n    const numVariations = experiment.variations.length;\n\n    // 1. If experiment has less than 2 variations, return immediately\n    if (numVariations < 2) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Invalid experiment\", { id: key });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 2. If the context is disabled, return immediately\n    if (this._ctx.enabled === false) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Context disabled\", { id: key });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 2.5. Merge in experiment overrides from the context\n    experiment = this._mergeOverrides(experiment);\n\n    // 3. If a variation is forced from a querystring, return the forced variation\n    const qsOverride = getQueryStringOverride(\n      key,\n      this._getContextUrl(),\n      numVariations\n    );\n    if (qsOverride !== null) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Force via querystring\", {\n          id: key,\n          variation: qsOverride,\n        });\n      return this._getResult(experiment, qsOverride, false, featureId);\n    }\n\n    // 4. If a variation is forced in the context, return the forced variation\n    if (this._ctx.forcedVariations && key in this._ctx.forcedVariations) {\n      const variation = this._ctx.forcedVariations[key];\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Force via dev tools\", {\n          id: key,\n          variation,\n        });\n      return this._getResult(experiment, variation, false, featureId);\n    }\n\n    // 5. Exclude if a draft experiment or not active\n    if (experiment.status === \"draft\" || experiment.active === false) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because inactive\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 6. Get the hash attribute and return if empty\n    const { hashValue } = this._getHashAttribute(experiment.hashAttribute);\n    if (!hashValue) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because missing hashAttribute\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 7. Exclude if user is filtered out (used to be called \"namespace\")\n    if (experiment.filters) {\n      if (this._isFilteredOut(experiment.filters)) {\n        process.env.NODE_ENV !== \"production\" &&\n          this.log(\"Skip because of filters\", {\n            id: key,\n          });\n        return this._getResult(experiment, -1, false, featureId);\n      }\n    } else if (\n      experiment.namespace &&\n      !inNamespace(hashValue, experiment.namespace)\n    ) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because of namespace\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 7.5. Exclude if experiment.include returns false or throws\n    if (experiment.include && !isIncluded(experiment.include)) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because of include function\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 8. Exclude if condition is false\n    if (experiment.condition && !this._conditionPasses(experiment.condition)) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because of condition\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 8.1. Exclude if user is not in a required group\n    if (\n      experiment.groups &&\n      !this._hasGroupOverlap(experiment.groups as string[])\n    ) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because of groups\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 8.2. Exclude if not on a targeted url\n    if (experiment.url && !this._urlIsValid(experiment.url as RegExp)) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because of url\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 9. Get bucket ranges and choose variation\n    const n = hash(\n      experiment.seed || key,\n      hashValue,\n      experiment.hashVersion || 1\n    );\n    const ranges =\n      experiment.ranges ||\n      getBucketRanges(\n        numVariations,\n        experiment.coverage === undefined ? 1 : experiment.coverage,\n        experiment.weights\n      );\n\n    const assigned = chooseVariation(n, ranges);\n\n    // 10. Return if not in experiment\n    if (assigned < 0) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because of coverage\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 11. Experiment has a forced variation\n    if (\"force\" in experiment) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Force variation\", {\n          id: key,\n          variation: experiment.force,\n        });\n      return this._getResult(\n        experiment,\n        experiment.force === undefined ? -1 : experiment.force,\n        false,\n        featureId\n      );\n    }\n\n    // 12. Exclude if in QA mode\n    if (this._ctx.qaMode) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because QA mode\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 12.5. Exclude if experiment is stopped\n    if (experiment.status === \"stopped\") {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because stopped\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 13. Build the result object\n    const result = this._getResult(experiment, assigned, true, featureId, n);\n\n    // 14. Fire the tracking callback\n    this._track(experiment, result);\n\n    // 15. Return the result\n    process.env.NODE_ENV !== \"production\" &&\n      this.log(\"In experiment\", {\n        id: key,\n        variation: result.variationId,\n      });\n    return result;\n  }\n\n  log(msg: string, ctx: Record<string, unknown>) {\n    if (!this.debug) return;\n    if (this._ctx.log) this._ctx.log(msg, ctx);\n    else console.log(msg, ctx);\n  }\n\n  private _track<T>(experiment: Experiment<T>, result: Result<T>) {\n    if (!this._ctx.trackingCallback) return;\n\n    const key = experiment.key;\n\n    // Make sure a tracking callback is only fired once per unique experiment\n    const k =\n      result.hashAttribute + result.hashValue + key + result.variationId;\n    if (this._trackedExperiments.has(k)) return;\n    this._trackedExperiments.add(k);\n\n    try {\n      this._ctx.trackingCallback(experiment, result);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n\n  private _mergeOverrides<T>(experiment: Experiment<T>): Experiment<T> {\n    const key = experiment.key;\n    const o = this._ctx.overrides;\n    if (o && o[key]) {\n      experiment = Object.assign({}, experiment, o[key]);\n      if (typeof experiment.url === \"string\") {\n        experiment.url = getUrlRegExp(\n          // eslint-disable-next-line\n          experiment.url as any\n        );\n      }\n    }\n\n    return experiment;\n  }\n\n  private _getHashAttribute(attr?: string) {\n    const hashAttribute = attr || \"id\";\n\n    let hashValue = \"\";\n    if (this._attributeOverrides[hashAttribute]) {\n      hashValue = this._attributeOverrides[hashAttribute];\n    } else if (this._ctx.attributes) {\n      hashValue = this._ctx.attributes[hashAttribute] || \"\";\n    } else if (this._ctx.user) {\n      hashValue = this._ctx.user[hashAttribute] || \"\";\n    }\n\n    return { hashAttribute, hashValue };\n  }\n\n  private _getResult<T>(\n    experiment: Experiment<T>,\n    variationIndex: number,\n    hashUsed: boolean,\n    featureId: string | null,\n    bucket?: number\n  ): Result<T> {\n    let inExperiment = true;\n    // If assigned variation is not valid, use the baseline and mark the user as not in the experiment\n    if (variationIndex < 0 || variationIndex >= experiment.variations.length) {\n      variationIndex = 0;\n      inExperiment = false;\n    }\n\n    const { hashAttribute, hashValue } = this._getHashAttribute(\n      experiment.hashAttribute\n    );\n\n    const meta: Partial<VariationMeta> = experiment.meta\n      ? experiment.meta[variationIndex]\n      : {};\n\n    const res: Result<T> = {\n      key: meta.key || \"\" + variationIndex,\n      featureId,\n      inExperiment,\n      hashUsed,\n      variationId: variationIndex,\n      value: experiment.variations[variationIndex],\n      hashAttribute,\n      hashValue,\n    };\n\n    if (meta.name) res.name = meta.name;\n    if (bucket !== undefined) res.bucket = bucket;\n    if (meta.passthrough) res.passthrough = meta.passthrough;\n\n    return res;\n  }\n\n  private _getContextUrl() {\n    return this._ctx.url || (isBrowser ? window.location.href : \"\");\n  }\n\n  private _urlIsValid(urlRegex: RegExp): boolean {\n    const url = this._getContextUrl();\n    if (!url) return false;\n\n    const pathOnly = url.replace(/^https?:\\/\\//, \"\").replace(/^[^/]*\\//, \"/\");\n\n    if (urlRegex.test(url)) return true;\n    if (urlRegex.test(pathOnly)) return true;\n    return false;\n  }\n\n  private _hasGroupOverlap(expGroups: string[]): boolean {\n    const groups = this._ctx.groups || {};\n    for (let i = 0; i < expGroups.length; i++) {\n      if (groups[expGroups[i]]) return true;\n    }\n    return false;\n  }\n}\n"],"names":["cacheSettings","staleTTL","cacheKey","backgroundSync","polyfills","fetch","globalThis","bind","undefined","SubtleCrypto","crypto","subtle","EventSource","localStorage","e","subscribedInstances","Map","cacheInitialized","cache","activeFetches","streams","supportsSSE","Set","setPolyfills","overrides","Object","assign","configureCache","clearAutoRefresh","async","clearCache","clear","updatePersistentCache","setItem","JSON","stringify","Array","from","entries","getKey","instance","apiHost","clientKey","getApiInfo","concat","onNewFeatureData","key","data","version","dateUpdated","staleAt","Date","now","existing","get","set","instances","forEach","setFeaturesOnInstance","encryptedFeatures","setEncryptedFeatures","setFeatures","features","getFeatures","fetchFeatures","endpoint","promise","then","res","headers","add","json","startAutoRefresh","delete","catch","Promise","resolve","has","channel","src","cb","event","parse","errors","onSSEError","addEventListener","onerror","readyState","destroyChannel","close","hashFnv32a","str","hval","l","length","i","charCodeAt","hash","seed","value","inRange","n","range","_regexCache","evalCondition","obj","condition","evalOr","conditions","evalAnd","k","v","evalConditionValue","getPath","path","parts","split","current","isArray","isOperatorObject","op","evalOperatorCondition","keys","filter","operator","actual","expected","includes","check","elemMatch","passed","j","regex","RegExp","replace","test","t","getType","console","error","isBrowser","window","document","base64ToBuf","b","Uint8Array","atob","c","GrowthBook","constructor","context","this","_ctx","_renderer","_trackedExperiments","_trackedFeatures","debug","_subscriptions","_rtQueue","_rtTimer","ready","_assigned","_forcedFeatureValues","_attributeOverrides","enableDevMode","_growthbook","dispatchEvent","Event","_refresh","options","autoRefresh","subs","subscribe","allowStale","updateInstance","Error","timeout","skipCache","getItem","parsed","_ref","initializeCache","timer","resolved","finish","clearTimeout","setTimeout","promiseTimeout","fetchFeaturesWithCache","refreshFeatures","_render","encryptedString","decryptionKey","importKey","name","iv","cipherText","plainTextBuffer","decrypt","TextDecoder","decode","setAttributes","attributes","setAttributeOverrides","setForcedVariations","vars","forcedVariations","setForcedFeatures","map","getAttributes","getAllResults","destroy","s","setRenderer","renderer","forceVariation","variation","run","experiment","result","_run","_fireSubscriptions","prev","inExperiment","variationId","_trackFeatureUsage","source","stringifiedValue","onFeatureUsage","push","on","q","realtimeKey","encodeURIComponent","mode","realtimeInterval","_getFeatureResult","ruleId","ret","off","experimentResult","isOn","evalFeature","isOff","getFeatureValue","defaultValue","feature","id","rules","rule","_conditionPasses","filters","_isFilteredOut","_isIncludedInRollout","hashAttribute","coverage","hashVersion","tracks","_track","force","variations","exp","weights","namespace","meta","ranges","phase","passthrough","hashValue","_getHashAttribute","some","attribute","r","featureId","numVariations","_getResult","enabled","_mergeOverrides","qsOverride","url","search","match","kv","_ref2","parseInt","getQueryStringOverride","_getContextUrl","status","active","inNamespace","include","isIncluded","groups","_hasGroupOverlap","_urlIsValid","assigned","chooseVariation","equal","fill","totalWeight","reduce","w","sum","cumulative","start","getBucketRanges","qaMode","log","msg","ctx","trackingCallback","o","regexString","escaped","getUrlRegExp","attr","user","variationIndex","hashUsed","bucket","location","href","urlRegex","pathOnly","expGroups"],"mappings":"AAsBA,MAAMA,EAA+B,CAEnCC,SAAU,IACVC,SAAU,kBACVC,gBAAgB,GAEZC,EAAuB,CAC3BC,MAAOC,WAAWD,MAAQC,WAAWD,MAAME,KAAKD,iBAAcE,EAC9DC,aAAcH,WAAWI,OAASJ,WAAWI,OAAOC,YAASH,EAC7DI,YAAaN,WAAWM,aAE1B,IACMN,WAAWO,eACbT,EAAUS,aAAeP,WAAWO,aAGtC,CADA,MAAOC,GACP,CAIF,MAAMC,EAA2D,IAAIC,IACrE,IAAIC,GAAmB,EACvB,MAAMC,EAAwC,IAAIF,IAC5CG,EAGF,IAAIH,IACFI,EAA6C,IAAIJ,IACjDK,EAAkC,IAAIC,IAGrC,SAASC,EAAaC,GAC3BC,OAAOC,OAAOtB,EAAWoB,EAC3B,CACO,SAASG,EAAeH,GAC7BC,OAAOC,OAAO1B,EAAewB,GACxBxB,EAAcG,gBACjByB,GAEJ,CAEOC,eAAeC,IACpBZ,EAAMa,QACNZ,EAAcY,QACdH,IACAX,GAAmB,QACbe,GACR,CA8BAH,eAAeG,IACb,IACE,IAAK5B,EAAUS,aAAc,aACvBT,EAAUS,aAAaoB,QAC3BjC,EAAcE,SACdgC,KAAKC,UAAUC,MAAMC,KAAKnB,EAAMoB,YAGlC,CADA,MAAOxB,GACP,CAEJ,CA4BA,SAASyB,EAAOC,GACd,MAAOC,EAASC,GAAaF,EAASG,aACtC,MAAO,CAAA,GAAAC,OAAIH,EAAYC,MAAAA,OAAAA,GAAaD,EAASC,EAC/C,CAsDA,SAASG,EAAiBC,EAAoBC,GAE5C,MAAMC,EAAUD,EAAKE,aAAe,GAC9BC,EAAU,IAAIC,KAAKA,KAAKC,MAAQpD,EAAcC,UAC9CoD,EAAWnC,EAAMoC,IAAIR,GAC3B,GAAIO,GAAYL,GAAWK,EAASL,UAAYA,EAE9C,YADAK,EAASH,QAAUA,GAKrBhC,EAAMqC,IAAIT,EAAK,CACbC,OACAC,UACAE,YAGFlB,IAGA,MAAMwB,EAAYzC,EAAoBuC,IAAIR,GAC1CU,GACEA,EAAUC,SAASjB,GAAakB,EAAsBlB,EAAUO,IACpE,CAEAlB,eAAe6B,EACblB,EACAO,SAEOA,EAAKY,kBACRnB,EAASoB,qBACPb,EAAKY,uBACLnD,EACAJ,EAAUK,cAEZ+B,EAASqB,YAAYd,EAAKe,UAAYtB,EAASuB,eACrD,CAEAlC,eAAemC,EACbxB,GAEA,MAAOM,EAAKL,EAASC,GAAaH,EAAOC,GACnCyB,EAAWxB,EAAU,iBAAmBC,EAE9C,IAAIwB,EAAU/C,EAAcmC,IAAIR,GA4BhC,OA3BKoB,IACHA,EAAW9D,EAAUC,MAAkC4D,GAEpDE,MAAMC,IACoC,YAArCA,EAAIC,QAAQf,IAAI,kBAClBjC,EAAYiD,IAAIxB,GAEXsB,EAAIG,UAEZJ,MAAMpB,IACLF,EAAiBC,EAAKC,GACtByB,EAAiBhC,GACjBrB,EAAcsD,OAAO3B,GACdC,KAER2B,OAAO5D,IAONK,EAAcsD,OAAO3B,GACd6B,QAAQC,QAAQ,CAAA,MAE3BzD,EAAcoC,IAAIT,EAAKoB,UAEZA,CACf,CAIA,SAASM,EAAiBhC,GACxB,MAAOM,EAAKL,EAASC,GAAaH,EAAOC,GACzC,GACExC,EAAcG,gBACdkB,EAAYwD,IAAI/B,IAChB1C,EAAUQ,YACV,CACA,GAAIQ,EAAQyD,IAAI/B,GAAM,OACtB,MAAMgC,EAAyB,CAC7BC,IAAK,IAAI3E,EAAUQ,YAAe6B,GAAAA,OAAAA,EAAeC,SAAAA,OAAAA,IACjDsC,GAAKC,IACH,IACE,MAAMV,EAA2BrC,KAAKgD,MAAMD,EAAMlC,MAClDF,EAAiBC,EAAKyB,GAEtBO,EAAQK,OAAS,CASnB,CARE,MAAOrE,GAOPsE,EAAWN,EAAShC,EACtB,GAEFqC,OAAQ,GAEV/D,EAAQmC,IAAIT,EAAKgC,GACjBA,EAAQC,IAAIM,iBAAiB,WAAYP,EAAQE,IAEjDF,EAAQC,IAAIO,QAAU,KACpBF,EAAWN,EAAShC,EAAI,CAE5B,CACF,CAEA,SAASsC,EAAWN,EAAwBhC,GAC1CgC,EAAQK,UACJL,EAAQK,OAAS,GAAgC,IAA3BL,EAAQC,IAAIQ,aACpCC,EAAeV,EAAShC,EAE5B,CAEA,SAAS0C,EAAeV,EAAwBhC,GAC9CgC,EAAQC,IAAIO,QAAU,KACtBR,EAAQC,IAAIU,QACZrE,EAAQqD,OAAO3B,EACjB,CAEA,SAASlB,IAEPP,EAAYU,QAGZX,EAAQqC,QAAQ+B,GAGhBzE,EAAoBgB,OACtB,CCxUA,SAAS2D,EAAWC,GAClB,IAAIC,EAAO,WACX,MAAMC,EAAIF,EAAIG,OAEd,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAGE,IACrBH,GAAQD,EAAIK,WAAWD,GACvBH,IACGA,GAAQ,IAAMA,GAAQ,IAAMA,GAAQ,IAAMA,GAAQ,IAAMA,GAAQ,IAErE,OAAOA,IAAS,CAClB,CAEO,SAASK,EAAKC,EAAcC,EAAenD,GAEhD,OAAgB,IAAZA,EACM0C,EAAWA,EAAWQ,EAAOC,GAAS,IAAM,IAAS,IAG/C,IAAZnD,EACM0C,EAAWS,EAAQD,GAAQ,IAAQ,KAIrC,CACV,CAOO,SAASE,EAAQC,EAAWC,GACjC,OAAOD,GAAKC,EAAM,IAAMD,EAAIC,EAAM,EACpC,CCxBA,MAAMC,EAAyC,CAAA,EAGxC,SAASC,EACdC,EACAC,GAGA,GAAI,QAASA,EACX,OAAOC,EAAOF,EAAKC,EAAe,KAEpC,GAAI,SAAUA,EACZ,OAAQC,EAAOF,EAAKC,EAAgB,MAEtC,GAAI,SAAUA,EACZ,OA0KJ,SAAiBD,EAAgBG,GAC/B,IAAK,IAAIb,EAAI,EAAGA,EAAIa,EAAWd,OAAQC,IACrC,IAAKS,EAAcC,EAAKG,EAAWb,IACjC,OAAO,EAGX,OAAO,CACT,CAjLWc,CAAQJ,EAAKC,EAAgB,MAEtC,GAAI,SAAUA,EACZ,OAAQF,EAAcC,EAAKC,EAAgB,MAI7C,IAAK,MAAOI,EAAGC,KAAMtF,OAAOa,QAAQoE,GAClC,IAAKM,EAAmBD,EAAGE,EAAQR,EAAKK,IAAK,OAAO,EAEtD,OAAO,CACT,CAGA,SAASG,EAAQR,EAAgBS,GAC/B,MAAMC,EAAQD,EAAKE,MAAM,KACzB,IAAIC,EAAeZ,EACnB,IAAK,IAAIV,EAAI,EAAGA,EAAIoB,EAAMrB,OAAQC,IAAK,CACrC,IAAIsB,GAA8B,iBAAZA,KAAwBF,EAAMpB,KAAMsB,GAGxD,OAAO,KAFPA,EAAUA,EAAQF,EAAMpB,GAI5B,CACA,OAAOsB,CACT,CAWA,SAASL,EAAmBN,EAA2BP,GAErD,GAAyB,iBAAdO,EACT,OAAOP,EAAQ,KAAOO,EAExB,GAAyB,iBAAdA,EACT,OAAe,EAARP,IAAcO,EAEvB,GAAyB,kBAAdA,EACT,QAASP,IAAUO,EAErB,GAAItE,MAAMkF,QAAQZ,KAAea,EAAiBb,GAChD,OAAOxE,KAAKC,UAAUgE,KAAWjE,KAAKC,UAAUuE,GAIlD,IAAK,MAAMc,KAAMd,EACf,IACGe,EACCD,EACArB,EACAO,EAAUc,IAGZ,OAAO,EAGX,OAAO,CACT,CAGA,SAASD,EAAiBd,GACxB,MAAMiB,EAAOjG,OAAOiG,KAAKjB,GACzB,OACEiB,EAAK5B,OAAS,GAAK4B,EAAKC,QAAQb,GAAe,MAATA,EAAE,KAAYhB,SAAW4B,EAAK5B,MAExE,CA4BA,SAAS2B,EACPG,EACAC,EACAC,GAEA,OAAQF,GACN,IAAK,MACH,OAAOC,IAAWC,EACpB,IAAK,MACH,OAAOD,IAAWC,EACpB,IAAK,MACH,OAAOD,EAASC,EAClB,IAAK,OACH,OAAOD,GAAUC,EACnB,IAAK,MACH,OAAOD,EAASC,EAClB,IAAK,OACH,OAAOD,GAAUC,EACnB,IAAK,UACH,OAAOA,EAAsB,OAAXD,EAA6B,OAAXA,EACtC,IAAK,MACH,OAAOC,EAASC,SAASF,GAC3B,IAAK,OACH,OAAQC,EAASC,SAASF,GAC5B,IAAK,OACH,OAAQb,EAAmBc,EAAUD,GACvC,IAAK,QACH,QAAKzF,MAAMkF,QAAQO,IACZb,EAAmBc,EAAUD,EAAO/B,QAC7C,IAAK,aACH,OA5CN,SAAmB+B,EAAaC,GAC9B,IAAK1F,MAAMkF,QAAQO,GAAS,OAAO,EACnC,MAAMG,EAAQT,EAAiBO,GAC1Bf,GAAWC,EAAmBc,EAAUf,GACxCA,GAAWP,EAAcO,EAAGe,GACjC,IAAK,IAAI/B,EAAI,EAAGA,EAAI8B,EAAO/B,OAAQC,IACjC,GAAI8B,EAAO9B,IAAMiC,EAAMH,EAAO9B,IAC5B,OAAO,EAGX,OAAO,CACT,CAiCakC,CAAUJ,EAAQC,GAC3B,IAAK,OACH,IAAK1F,MAAMkF,QAAQO,GAAS,OAAO,EACnC,IAAK,IAAI9B,EAAI,EAAGA,EAAI+B,EAAShC,OAAQC,IAAK,CACxC,IAAImC,GAAS,EACb,IAAK,IAAIC,EAAI,EAAGA,EAAIN,EAAO/B,OAAQqC,IACjC,GAAInB,EAAmBc,EAAS/B,GAAI8B,EAAOM,IAAK,CAC9CD,GAAS,EACT,KACF,CAEF,IAAKA,EAAQ,OAAO,CACtB,CACA,OAAO,EACT,IAAK,SACH,IACE,OAtHUE,EAsHMN,EArHjBvB,EAAY6B,KACf7B,EAAY6B,GAAS,IAAIC,OAAOD,EAAME,QAAQ,aAAc,WAEvD/B,EAAY6B,IAkHaG,KAAKV,EAGjC,CAFE,MAAO/G,GACP,OAAO,CACT,CACF,IAAK,QACH,OA5EN,SAAiBiG,GACf,GAAU,OAANA,EAAY,MAAO,OACvB,GAAI3E,MAAMkF,QAAQP,GAAI,MAAO,QAC7B,MAAMyB,SAAWzB,EACjB,MAAI,CAAC,SAAU,SAAU,UAAW,SAAU,aAAagB,SAASS,GAC3DA,EAEF,SACT,CAoEaC,CAAQZ,KAAYC,EAC7B,QAEE,OADAY,QAAQC,MAAM,qBAAuBf,IAC9B,EA9Hb,IAAkBQ,CAgIlB,CAGA,SAASzB,EAAOF,EAAgBG,GAC9B,IAAKA,EAAWd,OAAQ,OAAO,EAC/B,IAAK,IAAIC,EAAI,EAAGA,EAAIa,EAAWd,OAAQC,IACrC,GAAIS,EAAcC,EAAKG,EAAWb,IAChC,OAAO,EAGX,OAAO,CACT,CChKA,MAAM6C,EACc,oBAAXC,QAA8C,oBAAbC,SAEpCC,EAAeC,GACnBC,WAAW5G,KAAK6G,KAAKF,IAAKG,GAAMA,EAAEnD,WAAW,KAExC,MAAMoD,EA+BXC,YAAYC,GAIVC,KAAKC,EAAOD,KAAKD,QAHjBA,EAAUA,GAAW,GAIrBC,KAAKE,EAAY,KACjBF,KAAKG,EAAsB,IAAIpI,IAC/BiI,KAAKI,EAAmB,GACxBJ,KAAKK,OAAQ,EACbL,KAAKM,EAAiB,IAAIvI,IAC1BiI,KAAKO,EAAW,GAChBP,KAAKQ,EAAW,EAChBR,KAAKS,OAAQ,EACbT,KAAKU,EAAY,IAAIjJ,IACrBuI,KAAKW,EAAuB,IAAIlJ,IAChCuI,KAAKY,EAAsB,GAEvBb,EAAQxF,WACVyF,KAAKS,OAAQ,GAGXpB,GAAaU,EAAQc,gBACvBvB,OAAOwB,YAAcd,KACrBT,SAASwB,cAAc,IAAIC,MAAM,cAG/BjB,EAAQ5G,WACV6G,KAAKiB,EAAS,CAAA,GAAI,GAAM,EAE5B,CAEA3I,mBAA0B4I,SAClBlB,KAAKiB,EAASC,GAAS,GAAM,GAC/BA,GAAWA,EAAQC,aHfpB,SAAmBlI,GACxB,MAAOM,GAAOP,EAAOC,GACfmI,EAAO5J,EAAoBuC,IAAIR,IAAQ,IAAIxB,IACjDqJ,EAAKrG,IAAI9B,GACTzB,EAAoBwC,IAAIT,EAAK6H,EAC/B,CGWMC,CAAUrB,KAEd,CAEA1H,sBACE4I,SAEMlB,KAAKiB,EAASC,GAAS,GAAO,EACtC,CAEO9H,aACL,MAAO,EACJ4G,KAAKC,EAAK/G,SAAW,6BAA6B6F,QAAQ,OAAQ,IACnEiB,KAAKC,EAAK9G,WAAa,GAE3B,CAEAb,QACE4I,EACAI,EACAC,GAGA,GADAL,EAAUA,GAAW,IAChBlB,KAAKC,EAAK9G,UACb,MAAM,IAAIqI,MAAM,2BHzDflJ,eACLW,EACAwI,EACAC,EACAJ,EACAC,GAEA,MAAM/H,QAiCRlB,eACEW,EACAqI,EACAG,EACAC,GAEA,MAAOnI,GAAOP,EAAOC,GACfY,EAAM,IAAID,WAkDlBtB,iBACE,IAAIZ,EAAJ,CACAA,GAAmB,EACnB,IACE,GAAIb,EAAUS,aAAc,CAC1B,MAAMsF,QAAc/F,EAAUS,aAAaqK,QACzClL,EAAcE,UAEhB,GAAIiG,EAAO,CACT,MAAMgF,EAAwCjJ,KAAKgD,MAAMiB,GACrDgF,GAAU/I,MAAMkF,QAAQ6D,IAC1BA,EAAO1H,SAAQ2H,IAAiB,IAAftI,EAAKC,GAAKqI,EACzBlK,EAAMqC,IAAIT,EAAK,IACVC,EACHG,QAAS,IAAIC,KAAKJ,EAAKG,UACvB,GAGR,CACF,CAEA,CADA,MAAOpC,GACP,CApBoB,CAsBxB,CAxEQuK,GACN,MAAMhI,EAAWnC,EAAMoC,IAAIR,GAC3B,GAAIO,IAAa4H,IAAcJ,GAAcxH,EAASH,QAAUE,GAS9D,OAPIC,EAASH,QAAUE,EACrBY,EAAcxB,GAIdgC,EAAiBhC,GAEZa,EAASN,KACX,CACL,MAAMA,QAaV,SACEmB,EACA8G,GAEA,OAAO,IAAIrG,SAASC,IAClB,IACI0G,EADAC,GAAW,EAEf,MAAMC,EAAUzI,IACVwI,IACJA,GAAW,EACXD,GAASG,aAAaH,GACtB1G,EAAQ7B,GAAQ,MAAK,EAGnBiI,IACFM,EAAQI,YAAW,IAAMF,KAAUR,IAGrC9G,EAAQC,MAAMpB,GAASyI,EAAOzI,KAAO2B,OAAM,IAAM8G,KAAS,GAE9D,CAjCuBG,CAAe3H,EAAcxB,GAAWwI,GAC3D,OAAOjI,CACT,CACF,CAzDqB6I,CACjBpJ,EACAqI,EACAG,EACAC,GAEFH,GAAkB/H,SAAeW,EAAsBlB,EAAUO,EACnE,CG6CU8I,CACJtC,KACAkB,EAAQO,QACRP,EAAQQ,WAAa1B,KAAKC,EAAKY,cAC/BS,EACAC,EAEJ,CAEQgB,IACFvC,KAAKE,GACPF,KAAKE,GAET,CAEO5F,YAAYC,GACjByF,KAAKC,EAAK1F,SAAWA,EACrByF,KAAKS,OAAQ,EACbT,KAAKuC,GACP,CAEAjK,2BACEkK,EACAC,EACArL,GAIA,GAFAqL,EAAgBA,GAAiBzC,KAAKC,EAAKwC,eAAiB,KAC5DrL,EAASA,GAAWL,WAAWI,QAAUJ,WAAWI,OAAOC,QAEzD,MAAM,IAAIoK,MAAM,wCAElB,IACE,MAAMjI,QAAYnC,EAAOsL,UACvB,MACAlD,EAAYiD,GACZ,CAAEE,KAAM,UAAWpG,OAAQ,MAC3B,EACA,CAAC,UAAW,aAEPqG,EAAIC,GAAcL,EAAgB3E,MAAM,KACzCiF,QAAwB1L,EAAO2L,QACnC,CAAEJ,KAAM,UAAWC,GAAIpD,EAAYoD,IACnCrJ,EACAiG,EAAYqD,IAGd7C,KAAK1F,YAAY3B,KAAKgD,OAAM,IAAIqH,aAAcC,OAAOH,IAGvD,CAFE,MAAOvL,GACP,MAAM,IAAIiK,MAAM,6BAClB,CACF,CAEO0B,cAAcC,GACnBnD,KAAKC,EAAKkD,WAAaA,EACvBnD,KAAKuC,GACP,CAEOa,sBAAsBnL,GAC3B+H,KAAKY,EAAsB3I,EAC3B+H,KAAKuC,GACP,CACOc,oBAAoBC,GACzBtD,KAAKC,EAAKsD,iBAAmBD,GAAQ,CAAA,EACrCtD,KAAKuC,GACP,CAEOiB,kBAAkBC,GACvBzD,KAAKW,EAAuB8C,EAC5BzD,KAAKuC,GACP,CAEOmB,gBACL,MAAO,IAAK1D,KAAKC,EAAKkD,cAAenD,KAAKY,EAC5C,CAEOpG,cACL,OAAOwF,KAAKC,EAAK1F,UAAY,EAC/B,CAEO8G,UAAU5F,GAGf,OAFAuE,KAAKM,EAAevF,IAAIU,GAEjB,KACLuE,KAAKM,EAAepF,OAAOO,EAAG,CAElC,CAEOkI,gBACL,OAAO,IAAIlM,IAAIuI,KAAKU,EACtB,CAEOkD,UH/HF,IAAqB3K,EGiIxB+G,KAAKM,EAAe9H,QACpBwH,KAAKU,EAAUlI,QACfwH,KAAKG,EAAoB3H,QACzBwH,KAAKI,EAAmB,GACxBJ,KAAKO,EAAW,GACZP,KAAKQ,GACP0B,aAAalC,KAAKQ,GHvIIvH,EGyIZ+G,KHxIdxI,EAAoB0C,SAAS2J,GAAMA,EAAE3I,OAAOjC,KG0ItCoG,GAAaC,OAAOwB,cAAgBd,aAC/BV,OAAOwB,WAElB,CAEOgD,YAAYC,GACjB/D,KAAKE,EAAY6D,CACnB,CAEOC,eAAezK,EAAa0K,GACjCjE,KAAKC,EAAKsD,iBAAmBvD,KAAKC,EAAKsD,kBAAoB,GAC3DvD,KAAKC,EAAKsD,iBAAiBhK,GAAO0K,EAClCjE,KAAKuC,GACP,CAEO2B,IAAOC,GACZ,MAAMC,EAASpE,KAAKqE,EAAKF,EAAY,MAErC,OADAnE,KAAKsE,EAAmBH,EAAYC,GAC7BA,CACT,CAEQE,EAAsBH,EAA2BC,GACvD,MAAM7K,EAAM4K,EAAW5K,IAGjBgL,EAAOvE,KAAKU,EAAU3G,IAAIR,GAG7BgL,GACDA,EAAKH,OAAOI,eAAiBJ,EAAOI,cACpCD,EAAKH,OAAOK,cAAgBL,EAAOK,cAEnCzE,KAAKU,EAAU1G,IAAIT,EAAK,CAAE4K,aAAYC,WACtCpE,KAAKM,EAAepG,SAASuB,IAC3B,IACEA,EAAG0I,EAAYC,EAGjB,CAFE,MAAO7M,GACP4H,QAAQC,MAAM7H,EAChB,KAGN,CAEQmN,EAAmBnL,EAAasB,GAEtC,GAAmB,aAAfA,EAAI8J,OAAuB,OAG/B,MAAMC,EAAmBjM,KAAKC,UAAUiC,EAAI+B,OAC5C,GAAIoD,KAAKI,EAAiB7G,KAASqL,EAAnC,CAIA,GAHA5E,KAAKI,EAAiB7G,GAAOqL,EAGzB5E,KAAKC,EAAK4E,eACZ,IACE7E,KAAKC,EAAK4E,eAAetL,EAAKsB,EAE9B,CADA,MAAOtD,GACP,CAKC8H,GAAcC,OAAOxI,QAC1BkJ,KAAKO,EAASuE,KAAK,CACjBvL,MACAwL,GAAIlK,EAAIkK,KAEL/E,KAAKQ,IACRR,KAAKQ,EAAWlB,OAAO6C,YAAW,KAEhCnC,KAAKQ,EAAW,EAChB,MAAMwE,EAAI,IAAIhF,KAAKO,GACnBP,KAAKO,EAAW,GAGXP,KAAKC,EAAKgF,aAEf3F,OACGxI,MAAK,iCAAAuC,OAEF2G,KAAKC,EAAKgF,YAAW,YAAA5L,OACZ6L,mBAAmBvM,KAAKC,UAAUoM,KAE7C,CACErN,MAAO,WACPwN,KAAM,YAGThK,OAAM,QAEL,GACH6E,KAAKC,EAAKmF,kBAAoB,MA1CkB,CA4CvD,CAEQC,EACN9L,EACAqD,EACA+H,EACAW,EACAnB,EACAC,GAEA,MAAMmB,EAAqB,CACzB3I,QACAmI,KAAMnI,EACN4I,KAAM5I,EACN+H,SACAW,OAAQA,GAAU,IAQpB,OANInB,IAAYoB,EAAIpB,WAAaA,GAC7BC,IAAQmB,EAAIE,iBAAmBrB,GAGnCpE,KAAK0E,EAAmBnL,EAAKgM,GAEtBA,CACT,CAEOG,KAAoDnM,GACzD,OAAOyG,KAAK2F,YAAYpM,GAAKwL,EAC/B,CAEOa,MAAqDrM,GAC1D,OAAOyG,KAAK2F,YAAYpM,GAAKiM,GAC/B,CAEOK,gBAGLtM,EAAQuM,GACR,MAAMlJ,EAAQoD,KAAK2F,YAAmCpM,GAAKqD,MAC3D,OAAiB,OAAVA,EAAkBkJ,EAAsClJ,CACjE,CAOOmJ,QAGLC,GACA,OAAOhG,KAAK2F,YAAYK,EAC1B,CAEOL,YAGLK,GAEA,GAAIhG,KAAKW,EAAqBrF,IAAI0K,GAMhC,OAAOhG,KAAKqF,EACVW,EACAhG,KAAKW,EAAqB5G,IAAIiM,GAC9B,YAKJ,IAAKhG,KAAKC,EAAK1F,WAAayF,KAAKC,EAAK1F,SAASyL,GAG7C,OAAOhG,KAAKqF,EAAkBW,EAAI,KAAM,kBAI1C,MAAMD,EAAgC/F,KAAKC,EAAK1F,SAASyL,GAGzD,GAAID,EAAQE,MACV,IAAK,MAAMC,KAAQH,EAAQE,MAAO,CAEhC,GAAIC,EAAK/I,YAAc6C,KAAKmG,EAAiBD,EAAK/I,WAMhD,SAGF,GAAI+I,EAAKE,SAAWpG,KAAKqG,EAAeH,EAAKE,SAM3C,SAIF,GAAI,UAAWF,EAAM,CAEnB,IACGlG,KAAKsG,EACJJ,EAAKvJ,MAAQqJ,EACbE,EAAKK,cACLL,EAAKnJ,MACLmJ,EAAKM,SACLN,EAAKO,aAQP,SAgBF,OANIP,EAAKQ,QACPR,EAAKQ,OAAOxM,SAAS+E,IACnBe,KAAK2G,EAAO1H,EAAEkF,WAAYlF,EAAEmF,OAAO,IAIhCpE,KAAKqF,EAAkBW,EAAIE,EAAKU,MAAY,QAASV,EAAKF,GACnE,CACA,IAAKE,EAAKW,WAOR,SAGF,MAAMC,EAAqB,CACzBD,WAAYX,EAAKW,WACjBtN,IAAK2M,EAAK3M,KAAOyM,GAEf,aAAcE,IAAMY,EAAIN,SAAWN,EAAKM,UACxCN,EAAKa,UAASD,EAAIC,QAAUb,EAAKa,SACjCb,EAAKK,gBAAeO,EAAIP,cAAgBL,EAAKK,eAC7CL,EAAKc,YAAWF,EAAIE,UAAYd,EAAKc,WACrCd,EAAKe,OAAMH,EAAIG,KAAOf,EAAKe,MAC3Bf,EAAKgB,SAAQJ,EAAII,OAAShB,EAAKgB,QAC/BhB,EAAKvD,OAAMmE,EAAInE,KAAOuD,EAAKvD,MAC3BuD,EAAKiB,QAAOL,EAAIK,MAAQjB,EAAKiB,OAC7BjB,EAAKvJ,OAAMmK,EAAInK,KAAOuJ,EAAKvJ,MAC3BuJ,EAAKO,cAAaK,EAAIL,YAAcP,EAAKO,aACzCP,EAAKE,UAASU,EAAIV,QAAUF,EAAKE,SAGrC,MAAMvL,EAAMmF,KAAKqE,EAAKyC,EAAKd,GAE3B,GADAhG,KAAKsE,EAAmBwC,EAAKjM,GACzBA,EAAI2J,eAAiB3J,EAAIuM,YAC3B,OAAOpH,KAAKqF,EACVW,EACAnL,EAAI+B,MACJ,aACAsJ,EAAKF,GACLc,EACAjM,EAGN,CAUF,OAAOmF,KAAKqF,EACVW,OACyB/O,IAAzB8O,EAAQD,aAA6B,KAAOC,EAAQD,aACpD,eAEJ,CAEQQ,EACN3J,EACA4J,EACAxJ,EACAyJ,EACAC,GAEA,IAAK1J,QAAsB9F,IAAbuP,EAAwB,OAAO,EAE7C,MAAMa,UAAEA,GAAcrH,KAAKsH,EAAkBf,GAC7C,IAAKc,EACH,OAAO,EAGT,MAAMvK,EAAIJ,EAAKC,EAAM0K,EAAWZ,GAAe,GAE/C,OAAO1J,EACHF,EAAQC,EAAGC,QACE9F,IAAbuP,GACA1J,GAAK0J,CAEX,CAEQL,EAAiBhJ,GACvB,OAAOF,EAAc+C,KAAK0D,gBAAiBvG,EAC7C,CAEQkJ,EAAeD,GACrB,OAAOA,EAAQmB,MAAMnJ,IACnB,MAAMiJ,UAAEA,GAAcrH,KAAKsH,EAAkBlJ,EAAOoJ,WACpD,IAAKH,EAAW,OAAO,EACvB,MAAMvK,EAAIJ,EAAK0B,EAAOzB,KAAM0K,EAAWjJ,EAAOqI,aAAe,GAC7D,OAAQrI,EAAO8I,OAAOK,MAAME,GAAM5K,EAAQC,EAAG2K,IAAG,GAEpD,CAEQpD,EACNF,EACAuD,GAEA,MAAMnO,EAAM4K,EAAW5K,IACjBoO,EAAgBxD,EAAW0C,WAAWtK,OAG5C,GAAIoL,EAAgB,EAGlB,OAAO3H,KAAK4H,EAAWzD,GAAa,GAAG,EAAOuD,GAIhD,IAA0B,IAAtB1H,KAAKC,EAAK4H,QAGZ,OAAO7H,KAAK4H,EAAWzD,GAAa,GAAG,EAAOuD,GAIhDvD,EAAanE,KAAK8H,EAAgB3D,GAGlC,MAAM4D,EFpdH,SACL/B,EACAgC,EACAL,GAEA,IAAKK,EACH,OAAO,KAGT,MAAMC,EAASD,EAAInK,MAAM,KAAK,GAC9B,IAAKoK,EACH,OAAO,KAGT,MAAMC,EAAQD,EACXlJ,QAAQ,MAAO,IACflB,MAAM,KACN4F,KAAK0E,GAAOA,EAAGtK,MAAM,IAAK,KAC1BO,QAAOyD,IAAA,IAAEtE,GAAEsE,EAAA,OAAKtE,IAAMyI,CAAE,IACxBvC,KAAI2E,IAAA,IAAI5K,CAAAA,GAAE4K,EAAA,OAAKC,SAAS7K,EAAE,IAE7B,OAAI0K,EAAM3L,OAAS,GAAK2L,EAAM,IAAM,GAAKA,EAAM,GAAKP,EAC3CO,EAAM,GAER,IACT,CE2buBI,CACjB/O,EACAyG,KAAKuI,IACLZ,GAEF,GAAmB,OAAfI,EAMF,OAAO/H,KAAK4H,EAAWzD,EAAY4D,GAAY,EAAOL,GAIxD,GAAI1H,KAAKC,EAAKsD,kBAAoBhK,KAAOyG,KAAKC,EAAKsD,iBAOjD,OAAOvD,KAAK4H,EAAWzD,EANLnE,KAAKC,EAAKsD,iBAAiBhK,IAMC,EAAOmO,GAIvD,GAA0B,UAAtBvD,EAAWqE,SAA4C,IAAtBrE,EAAWsE,OAK9C,OAAOzI,KAAK4H,EAAWzD,GAAa,GAAG,EAAOuD,GAIhD,MAAML,UAAEA,GAAcrH,KAAKsH,EAAkBnD,EAAWoC,eACxD,IAAKc,EAKH,OAAOrH,KAAK4H,EAAWzD,GAAa,GAAG,EAAOuD,GAIhD,GAAIvD,EAAWiC,SACb,GAAIpG,KAAKqG,EAAelC,EAAWiC,SAKjC,OAAOpG,KAAK4H,EAAWzD,GAAa,GAAG,EAAOuD,QAE3C,GACLvD,EAAW6C,YFvlBV,SACLK,EACAL,GAEA,MAAMlK,EAAIJ,EAAK,KAAOsK,EAAU,GAAIK,EAAW,GAC/C,OAAOvK,GAAKkK,EAAU,IAAMlK,EAAIkK,EAAU,EAC5C,CEklBO0B,CAAYrB,EAAWlD,EAAW6C,WAMnC,OAAOhH,KAAK4H,EAAWzD,GAAa,GAAG,EAAOuD,GAIhD,GAAIvD,EAAWwE,UF1fZ,SAAoBA,GACzB,IACE,OAAOA,GAIT,CAHE,MAAOpR,GAEP,OADA4H,QAAQC,MAAM7H,IACP,CACT,CACF,CEmf+BqR,CAAWzE,EAAWwE,SAK/C,OAAO3I,KAAK4H,EAAWzD,GAAa,GAAG,EAAOuD,GAIhD,GAAIvD,EAAWhH,YAAc6C,KAAKmG,EAAiBhC,EAAWhH,WAK5D,OAAO6C,KAAK4H,EAAWzD,GAAa,GAAG,EAAOuD,GAIhD,GACEvD,EAAW0E,SACV7I,KAAK8I,EAAiB3E,EAAW0E,QAMlC,OAAO7I,KAAK4H,EAAWzD,GAAa,GAAG,EAAOuD,GAIhD,GAAIvD,EAAW6D,MAAQhI,KAAK+I,EAAY5E,EAAW6D,KAKjD,OAAOhI,KAAK4H,EAAWzD,GAAa,GAAG,EAAOuD,GAIhD,MAAM5K,EAAIJ,EACRyH,EAAWxH,MAAQpD,EACnB8N,EACAlD,EAAWsC,aAAe,GAUtBuC,EF9oBH,SAAyBlM,EAAWoK,GACzC,IAAK,IAAI1K,EAAI,EAAGA,EAAI0K,EAAO3K,OAAQC,IACjC,GAAIK,EAAQC,EAAGoK,EAAO1K,IACpB,OAAOA,EAGX,OAAQ,CACV,CEuoBqByM,CAAgBnM,EAP/BqH,EAAW+C,QFpnBV,SACLS,EACAnB,EACAO,IAEAP,OAAwBvP,IAAbuP,EAAyB,EAAIA,GAGzB,EAIbA,EAAW,EACFA,EAAW,IAIpBA,EAAW,GAIb,MAAM0C,GAzDwBpM,EAyDA6K,IAxDrB,EAAU,GACZ,IAAI9O,MAAMiE,GAAGqM,KAAK,EAAIrM,GAFxB,IAAyBA,GA0D9BiK,EAAUA,GAAWmC,GACT3M,SAAWoL,IAMrBZ,EAAUmC,GAIZ,MAAME,EAAcrC,EAAQsC,QAAO,CAACC,EAAGC,IAAQA,EAAMD,GAAG,IACpDF,EAAc,KAAQA,EAAc,QAItCrC,EAAUmC,GAIZ,IAAIM,EAAa,EACjB,OAAOzC,EAAQtD,KAAK6F,IAClB,MAAMG,EAAQD,EAEd,OADAA,GAAcF,EACP,CAACG,EAAOA,EAASjD,EAAsB8C,EAAE,GAEpD,CEqkBMI,CACE/B,OACwB1Q,IAAxBkN,EAAWqC,SAAyB,EAAIrC,EAAWqC,SACnDrC,EAAW4C,UAMf,GAAIiC,EAAW,EAKb,OAAOhJ,KAAK4H,EAAWzD,GAAa,GAAG,EAAOuD,GAIhD,GAAI,UAAWvD,EAMb,OAAOnE,KAAK4H,EACVzD,OACqBlN,IAArBkN,EAAWyC,OAAuB,EAAIzC,EAAWyC,OACjD,EACAc,GAKJ,GAAI1H,KAAKC,EAAK0J,OAKZ,OAAO3J,KAAK4H,EAAWzD,GAAa,GAAG,EAAOuD,GAIhD,GAA0B,YAAtBvD,EAAWqE,OAKb,OAAOxI,KAAK4H,EAAWzD,GAAa,GAAG,EAAOuD,GAIhD,MAAMtD,EAASpE,KAAK4H,EAAWzD,EAAY6E,GAAU,EAAMtB,EAAW5K,GAWtE,OARAkD,KAAK2G,EAAOxC,EAAYC,GAQjBA,CACT,CAEAwF,IAAIC,EAAaC,GACV9J,KAAKK,QACNL,KAAKC,EAAK2J,IAAK5J,KAAKC,EAAK2J,IAAIC,EAAKC,GACjC3K,QAAQyK,IAAIC,EAAKC,GACxB,CAEQnD,EAAUxC,EAA2BC,GAC3C,IAAKpE,KAAKC,EAAK8J,iBAAkB,OAEjC,MAGMxM,EACJ6G,EAAOmC,cAAgBnC,EAAOiD,UAJpBlD,EAAW5K,IAI2B6K,EAAOK,YACzD,IAAIzE,KAAKG,EAAoB7E,IAAIiC,GAAjC,CACAyC,KAAKG,EAAoBpF,IAAIwC,GAE7B,IACEyC,KAAKC,EAAK8J,iBAAiB5F,EAAYC,EAGzC,CAFE,MAAO7M,GACP4H,QAAQC,MAAM7H,EAChB,CAPqC,CAQvC,CAEQuQ,EAAmB3D,GACzB,MAAM5K,EAAM4K,EAAW5K,IACjByQ,EAAIhK,KAAKC,EAAKhI,UAWpB,OAVI+R,GAAKA,EAAEzQ,IAEqB,iBAD9B4K,EAAajM,OAAOC,OAAO,CAAA,EAAIgM,EAAY6F,EAAEzQ,KACvByO,MACpB7D,EAAW6D,IF9tBZ,SAAsBiC,GAC3B,IACE,MAAMC,EAAUD,EAAYlL,QAAQ,aAAc,SAClD,OAAO,IAAID,OAAOoL,EAIpB,CAHE,MAAO3S,GAEP,YADA4H,QAAQC,MAAM7H,EAEhB,CACF,CEstByB4S,CAEfhG,EAAW6D,MAKV7D,CACT,CAEQmD,EAAkB8C,GACxB,MAAM7D,EAAgB6D,GAAQ,KAE9B,IAAI/C,EAAY,GAShB,OARIrH,KAAKY,EAAoB2F,GAC3Bc,EAAYrH,KAAKY,EAAoB2F,GAC5BvG,KAAKC,EAAKkD,WACnBkE,EAAYrH,KAAKC,EAAKkD,WAAWoD,IAAkB,GAC1CvG,KAAKC,EAAKoK,OACnBhD,EAAYrH,KAAKC,EAAKoK,KAAK9D,IAAkB,IAGxC,CAAEA,gBAAec,YAC1B,CAEQO,EACNzD,EACAmG,EACAC,EACA7C,EACA8C,GAEA,IAAIhG,GAAe,GAEf8F,EAAiB,GAAKA,GAAkBnG,EAAW0C,WAAWtK,UAChE+N,EAAiB,EACjB9F,GAAe,GAGjB,MAAM+B,cAAEA,EAAac,UAAEA,GAAcrH,KAAKsH,EACxCnD,EAAWoC,eAGPU,EAA+B9C,EAAW8C,KAC5C9C,EAAW8C,KAAKqD,GAChB,GAEEzP,EAAiB,CACrBtB,IAAK0N,EAAK1N,KAAO,GAAK+Q,EACtB5C,YACAlD,eACA+F,WACA9F,YAAa6F,EACb1N,MAAOuH,EAAW0C,WAAWyD,GAC7B/D,gBACAc,aAOF,OAJIJ,EAAKtE,OAAM9H,EAAI8H,KAAOsE,EAAKtE,WAChB1L,IAAXuT,IAAsB3P,EAAI2P,OAASA,GACnCvD,EAAKG,cAAavM,EAAIuM,YAAcH,EAAKG,aAEtCvM,CACT,CAEQ0N,IACN,OAAOvI,KAAKC,EAAK+H,MAAQ3I,EAAYC,OAAOmL,SAASC,KAAO,GAC9D,CAEQ3B,EAAY4B,GAClB,MAAM3C,EAAMhI,KAAKuI,IACjB,IAAKP,EAAK,OAAO,EAEjB,MAAM4C,EAAW5C,EAAIjJ,QAAQ,eAAgB,IAAIA,QAAQ,WAAY,KAErE,QAAI4L,EAAS3L,KAAKgJ,MACd2C,EAAS3L,KAAK4L,EAEpB,CAEQ9B,EAAiB+B,GACvB,MAAMhC,EAAS7I,KAAKC,EAAK4I,QAAU,CAAA,EACnC,IAAK,IAAIrM,EAAI,EAAGA,EAAIqO,EAAUtO,OAAQC,IACpC,GAAIqM,EAAOgC,EAAUrO,IAAK,OAAO,EAEnC,OAAO,CACT"}